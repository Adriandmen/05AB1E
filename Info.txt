Functions:

!	= pop a,     push factorial(a)
"	= start/end string literal
#	= pop a      if true: break/end (used in infinite loops)
$	=            push 1 and input (used for sequences)
%	= pop a,b    push (a % b)
&	= pop a,b    push a AND b
'	=            push char ( 'a pushes "a" )
(	= pop a      push -a
)	=            wrap total stack to an array
*	= pop a,b    push (a * b)
+	= pop a,b    push (a + b)
,	= pop a      print(a)
-	= pop a,b    push (a - b) or if a or b is not a decimal, push a.remove(all chars of b)
.	= two char functions
/	= pop a,b    push (a / b)
0	= numeric literal
1	= numeric literal
2	= numeric literal
3	= numeric literal
4	= numeric literal
5	= numeric literal
6	= numeric literal
7	= numeric literal
8	= numeric literal
9	= numeric literal
:	= pop a,b,c  a.replace(b, c) / infinite replacement
;	= pop a      push a / 2
<	= pop a      push a - 1
=	=            print last item
>	= pop a      push a + 1
?	= pop a      print a no newline
@	= pop a      push stack(a)
A	=            push 'abcdefghijklmnopqrstuvwxyz'
B	= pop a,b    push base(a, b)
C	= pop a      push int(a, 2)
D	= pop a      push a, a
E	=            push eval(input())
F	= pop a      for N in range(0, a) { }: F(commands)} / N = variable
G	= pop a      for N in range(1, a) { }: F(commands)} / N = variable
H	= pop a      push int(a, 16)
I	=            push input()
J	= pop a      push ''.join(a) if a is list / if not, then push ''.join(stack)
K	= pop a,b    push a with no b's
L	= pop a      push [1 .. a]
M	=            push the largest number in the stack
N	=            reserved for variables
O	= pop a      push total sum (only on lists)
P	= pop a      push total product (only on lists)
Q	= pop a,b    push a == b (bool)
R	= pop a      push reversed(a)
S	= pop a      push all chars a seperate
T	=            push 10
U	= pop a      assign X to a
V	= pop a      assign Y to a
W	= pop a      assign Z to input and pushes input
X	=            integer variable
Y	=            integer variable
Z	=            integer variable
[	=            infinite loop start
\	=            delete last item
]	=            infinite loop end
^	= pop a,b    push a XOR b
_	= pop a      push negative bool
`	= pop a      push flattend a
a	= pop a      push is_alpha(a)
b	= pop a      push bin(a)
c	= pop a,b    push a nCr b
d	= pop a      push is_number(a)
e	= pop a,b    push a nPr b
f	= pop a      push list of prime factors (no duplicates)
g	= pop a      push length of a
h	= pop a      push hex(a)
i	= pop a      if statement: iTHEN}: if true { then }
j	= pop a      max_a_spaces.join(stack)
k	= pop a,b    push 1-indexed index of b in a (-1 when not found)
l	= pop a      push lower_case(a)
m	= pop a,b    push a**b
n	= pop a      push a**2
o	= pop a      push 2**a
p	= pop a      push isPrime(a)
q	=            terminates the program
r	=            reverse stack
s	= pop a,b    push b,a
t	= pop a      push sqrt(a)
u	= pop a      push upper_case(a)
v	= pop a      range loop: for y in a (y = string, N = index)
w	=            wait one second
x	= pop a      push a, a * 2
y	=            push string variable (used in mapping loops)
z	= pop a      push 1 / a
{	= pop a      push sorted a
|	=            push the rest of input as an array with strings
}	=            used for if statements
~	= pop a,b    push a OR b

Extended ASCII characters (CP-1252)

€ 0     = for each command
‚ 1	= pop a,b    push [a, b]
ƒ 2	= pop a      push for N in range(0, a + 1)
„ 3	= 2 char string / can also be used for 2 compressed strings
… 4	= 3 char string / can also be used for 3 compressed strings
† 5	= pop a,b    push a with b filtered to the front
‡ 6	= pop a,b,c  push a.transliterate(b -> c)
ˆ 7	= pop a      add to global array
‰ 8	= pop a,b    push a divmod b
Š 9	= pop a,b,c  push c,a,b
‹ 10	= pop a,b    push a < b
Œ 11	= pop a      push substrings(a)
Ž 12	= break if stack is empty
‘ -	= for compressed strings (upper)
’ - 	= for compressed strings (no implicit space)
“ -	= for compressed strings (normal)
” -	= for compressed strings (title)
• 15	= start/end a 1-9 char compressed string
– 16	= pop a      if 1, print N (used in loops)
— 17	= pop a      if 1, print y (used in loops)
˜   	= 
™ 19	= pop a      push title_cased(a)
š 20	= pop a      push switch_cased(a)
› 21	= pop a,b    push a > b
œ 22	= pop a      push permutations(a)

ž 23  > ža           push current hours
        žb           push current minutes
        žc           push current seconds
        žd           push current microseconds
        že	     push current day
        žf           push current month
        žg           push current year
        žh           push [0-9]
        ži           push [a-zA-Z]
        žj           push [a-zA-Z0-9_]
        žk           push [z-aZ-A]
        žl           push [z-aZ-A9-0_]
        žm           push [9-0]
        žn           push [A-Za-z]
        žo           push [Z-Az-a]
        žp           push [Z-A]
	žq	     push pi
	žr	     push e
	žs	     pop a, push pi to a digits (max. 100000)
	žt	     pop a, push e to a digits (max. 10000)
	žu	     push ()<>[]{}
	žv	     push 16
	žw	     push 32
	žx	     push 64
	žy	     push 128
	žz	     push 256
	žA	     push 512
	žB	     push 1024
	žC	     push 2048
	žD	     push 4096
	žE	     push 8192
	žF	     push 16384
	žG	     push 32768
	žH	     push 65536
	žI	     push 2147483648
	žJ	     push 4294967296


Ÿ 24	= pop a,b    push [a, ..., b]
¡ 25	= pop a,b    push a.split(b)  
¢ 26	= pop a,b    push a.count(b)
£ 27	= pop a,b    push a[0:b]
¤ 28	= get a      push tail(a)
¥ 29	= pop a      push delta's a
¦ 30	= pop a      push a[1:]
§ 31	= pop a      push str(a)
¨ 32	= pop a      push a[0:-1]
© 33	= store a in register_c without popping
ª 34	= pop a      push sentence_cased(a)
« 35	= pop a,b    push concatenated(a, b)
¬ 36	= get a      push head(a)
® 37	=            push the last item from register_c
¯ 38	=            push global array
° 39	= pop a      push 10 ** a
± 40	=
² 41	=            push the second item from the input history
³ 42	=            push the third item from the input history
´ 43	=            clear global array
µ 44	= pop a      while counter_variable != a, do...
¶ 45	=            push newline character
· 46	= pop a      push 2 * a
¸ 47	=
¹ 48	=            push the first item from the input history
º 49	=            push len(stack) > 0
» 50	= (pop a)    suspend / restore function
¼ 51	= counter_variable += 1
½ 52	= pop a,     if 1, then counter_variable -= 1
¾ 53	=            push counter_variable
¿ 54	= pop a      push gcd(a)
À 55	= pop a      push a rotated 1 left
Á 56	= pop a      push a rotated 1 right
Â 57	= pop a      push bifurcated a
Ã 58	= pop a,b    push a.keep(b)
Ä 59	= pop a      push abs(a)
Å 60	= list commands
Æ 61	= pop a      push reduced substraction a
Ç 62	= pop a      push ASCII value of a
È 63	= pop a      push a % 2 == 0 (is even)
É 64	= pop a      push a % 2 == 1 (is uneven)
Ê 65	= pop a,b    push a != b
Ë 66	=
Ì 67	= pop a      push a + 2
Í 68	= pop a      push a - 2
Î 69	= push 0 and input
Ï 70	= pop a,b    push the elements from a at which the same index at b is 1
Ð 71	= triplicate top of stack (pop a, push a, push a, push a)
Ñ 72	= pop a      push divisors(a)
Ò 73	= pop a      push list of prime factors (with duplicates)
Ó 74	= pop a      push list of exponents of prime factors (2^a, 3^b, 5^c, 7^d, etc.)
Ô 75	= pop a      push connected uniquified a
Õ 76	= pop a      push euler_totient(a)
Ö 77	= pop a,b    push a % b == 0
× 78	= pop a,b    push a × b (strings)
Ø 79	= pop a      push ath prime (zero-indexed)
Ù 80	= pop a      push uniquified a
Ú 81	= pop a      push reverse uniquified a
Û 82	= pop a,b    push a with leading b's trimmed off
Ü 83	= pop a,b    push a with trailing b's trimmed off
Ý 84	= pop a,b    push [a, ..., b - 1]
Þ 85	= pop a      push float(a)
ß 86	= pop smallest element of list
à 87	= pop greatest element of list
á 88	= pop a      push only letters of a
â 89	= pop a,(b)  push cartesian product
ã 90	= pop a,b    push a choose b (cartesian product repeat)
ä 91	= pop a,b    push a sliced into b pieces
å 92	= pop a,b    push a in b
æ 93	= pop a      push powerset(a)
ç 94	= pop a      push char a
è 95	=
é 96	=
ê 97    =
ë 98	= else statement
ì 99	=
í 13	=
î 14	= pop a      push round_up(a)
ï 18	= pop a      push int(a)
ð	=            push a space character
ñ	= pop a,b,c  push a + b merged with c as merge character
ò	= pop a      push inclusive round up a
ó	= pop a      push inclusive round down a
ô	=
õ	=  	     push empty string
ö	= pop a,b    push int(a, b)
÷	= pop a,b    push a split in pieces of b
ø	= pop a      push zipped a
ù	=
ú	= 
û	=
ü	=
ý	= pop (a),b  push b.join(a) if a is list, else b.join(stack)
þ	= pop a      push only digits of a
ÿ	= used for string interpolation, pop a and replace ÿ with str(a)

0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!"#$%&'()*+/:;<=>?@[\]^_`{|}

Extended functions:

.€	= debug printer
.ä	= debug printer
.A      = pop a      push acronymified a
.e      = pop a      run with experimental python evaluation (does not work in safe mode)
.E      = pop a      run with experimental batch evaluation (does not work in safe mode)
.V      = pop a      run as 05AB1E code
.j	= pop a      0-indexed max_spaces.join(stack) grid
.J      = pop a      1-indexed max_spaces.join(stack) grid
.l      = pop a      push is_lower(a)
.o      = pop a,b    push overlap(b)
.O  	= pop a,b    push connected_overlap(b)
.u      = pop a      push is_upper(a)
.L	= pop a,b    push log_b(a)
.:	= pop a,b,c  push a.replace(b, c)
.²	= pop a      push log_2(a)